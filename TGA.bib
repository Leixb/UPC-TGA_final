
@online{rmit_-_cs_lecture_2017,
	title = {Lecture: Graphics pipeline},
	url = {https://web.archive.org/web/20171207095603/http://goanna.cs.rmit.edu.au/~gl/teaching/rtr%263dgp/notes/pipeline.html},
	shorttitle = {Lecture},
	author = {{RMIT} - {CS}},
	urldate = {2021-06-03},
	date = {2017-12-07},
	file = {Snapshot:/home/leix/Zotero/storage/WNEBV2WA/pipeline.html:text/html}
}

@unpublished{fernandez_tarjetas_2021,
	title = {Tarjetas Gráficas y Aceleradores},
	author = {Fernández, Agustín},
	date = {2021}
}

@unpublished{lawrence_3d_2012,
	title = {3D Polygon Rendering Pipeline},
	url = {https://web.archive.org/web/20161229102150/http://www.cs.virginia.edu/~gfx/Courses/2012/IntroGraphics/lectures/13-Pipeline.pdf},
	author = {Lawrence, Jason},
	urldate = {2021-06-03},
	date = {2012-10-22},
	file = {PDF Snapshot:/home/leix/Zotero/storage/HPIV2EHW/2016 - Wayback Machine.pdf:application/pdf}
}

@online{noauthor_rendering_2021,
	title = {Rendering Pipeline Overview},
	url = {https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview},
	titleaddon = {{OpenGL} Wiki},
	type = {Wiki},
	urldate = {2021-06-03},
	date = {2021-02-11},
	file = {Rendering Pipeline Overview - OpenGL Wiki:/home/leix/Zotero/storage/9NKITADE/Rendering_Pipeline_Overview.html:text/html}
}

@book{moller_real-time_2018,
	location = {Boca Raton},
	edition = {Fourth edition},
	title = {Real-time rendering},
	isbn = {978-1-351-81615-1},
	pagetotal = {1196},
	publisher = {Taylor and Francis, {CRC} Press},
	author = {Möller, Tomas},
	date = {2018},
	langid = {english},
	keywords = {Computer graphics, Real-time data processing, Rendering (Computer graphics)},
	file = {Möller - 2018 - Real-time rendering.pdf:/home/leix/Zotero/storage/CM7IYCCA/Möller - 2018 - Real-time rendering.pdf:application/pdf}
}

@online{giesen_trip_2011,
	title = {A trip through the Graphics Pipeline 2011: Index},
	url = {https://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index/},
	shorttitle = {A trip through the Graphics Pipeline 2011},
	abstract = {Welcome. This is the index page for a series of blog posts I’m currently writing about the D3D/{OpenGL} graphics pipelines as actually implemented by {GPUs}. A lot of this is well known among gra…},
	titleaddon = {The ryg blog},
	author = {Giesen, Fabian},
	urldate = {2021-06-11},
	date = {2011-07-09},
	langid = {english},
	file = {Snapshot:/home/leix/Zotero/storage/JRFSYKSK/a-trip-through-the-graphics-pipeline-2011-index.html:text/html}
}

@online{noauthor_virtual_2008,
	title = {virtual \{mo\}ritz » {REYES}, Primitives \& Some Philosophy},
	url = {https://web.archive.org/web/20080315063655/http://www.virtualritz.com/essays/reyes-primitives-some-philosophy/},
	urldate = {2021-06-11},
	date = {2008-03-15},
	file = {Snapshot:/home/leix/Zotero/storage/KI8NCBDA/reyes-primitives-some-philosophy.html:text/html}
}

@online{shua_rispec_2011,
	title = {{RiSpec} or Welcome to Renderman},
	url = {https://joshuaandrewjackson.wordpress.com/2011/12/29/blender-to-prman-chapter-2-rispec-or-welcome-to-renderman/},
	shorttitle = {Blender to {PRMan}},
	abstract = {January 11, 2012 Update: Work in Progress. Extending {RSL} information. Continuing to fill in temp pictures until a full overview of spec complete. Currently completing section [{RSL} {ShadeOp}: Function…},
	titleaddon = {Farbenkugel Express},
	author = {Shua, Jackson},
	urldate = {2021-06-11},
	date = {2011-12-28},
	langid = {english},
	file = {Snapshot:/home/leix/Zotero/storage/R4SS3NMG/blender-to-prman-chapter-2-rispec-or-welcome-to-renderman.html:text/html}
}

@report{volkov_understanding_nodate,
	title = {Understanding Latency Hiding on {GPUs}},
	pages = {128},
	author = {Volkov, Vasily},
	langid = {english},
	file = {Volkov - Understanding Latency Hiding on GPUs.pdf:/home/leix/Zotero/storage/5JK255FT/Volkov - Understanding Latency Hiding on GPUs.pdf:application/pdf}
}

@online{noauthor_introducing_2018,
	title = {Introducing the {NVIDIA} {RTX} Ray Tracing Platform},
	url = {https://developer.nvidia.com/rtx/raytracing},
	abstract = {{NVIDIA} {RTX} is a \#raytracing platform that brings real-time, cinematic-quality rendering to content creators and game developers. Learn more.},
	titleaddon = {{NVIDIA} Developer},
	urldate = {2021-06-11},
	date = {2018-03-06},
	langid = {english},
	file = {Snapshot:/home/leix/Zotero/storage/U4E9T2ZX/raytracing.html:text/html}
}

@artwork{leopold_english_2017,
	title = {English:  Illustration of a simple Ray Tracing algorithm for one pixel up to the first bounce.},
	url = {https://commons.wikimedia.org/wiki/File:Ray_Tracing_Illustration_First_Bounce.png},
	shorttitle = {English},
	author = {Leopold, Nikolaus},
	urldate = {2021-06-11},
	date = {2017-05-02},
	file = {Wikimedia Snapshot:/home/leix/Zotero/storage/JL8SHSV8/FileRay_Tracing_Illustration_First_Bounce.html:text/html}
}

@online{noauthor_opencl_2013,
	title = {{OpenCL} - The Open Standard for Parallel Programming of Heterogeneous Systems},
	url = {https://www.khronos.org//},
	titleaddon = {The Khronos Group},
	urldate = {2021-06-12},
	date = {2013-07-21},
	langid = {english},
	note = {Section: {API}},
	file = {Snapshot:/home/leix/Zotero/storage/I4NP5FUA/opencl.html:text/html}
}

@online{noauthor_cuda_2017,
	title = {{CUDA} Zone},
	url = {https://developer.nvidia.com/cuda-zone},
	abstract = {{CUDA}® is a parallel computing platform and programming model developed by {NVIDIA} for general computing on graphical processing units ({GPUs}). With {CUDA}, developers are able to dramatically speed up computing applications by harnessing the power of {GPUs}. In {GPU}-accelerated applications, the sequential part of the workload runs on the {CPU} – which is optimized for single-threaded performance – while the compute intensive portion of the application runs on thousands of {GPU} cores in parallel.},
	titleaddon = {{NVIDIA} Developer},
	urldate = {2021-06-12},
	date = {2017-07-18},
	langid = {english},
	file = {Snapshot:/home/leix/Zotero/storage/NJ54MEY2/cuda-zone.html:text/html}
}

@online{noauthor_about_nodate,
	title = {About {OpenACC} {\textbar} {OpenACC}},
	url = {https://www.openacc.org/about},
	urldate = {2021-06-12},
	file = {About OpenACC | OpenACC:/home/leix/Zotero/storage/Q3M6FF8L/about.html:text/html}
}

@article{heckbert_survey_1986,
	title = {Survey Of Texture Mapping},
	volume = {6},
	doi = {10.1109/MCG.1986.276672},
	abstract = {Texture mapping is one of the most successful new techniques in high-quality image synthesis. It can enchance the visual richness of raster-scan images immensely while entailing only a relatively smann increase in computation. The technique has been applied to a number of surface attributes: surface color, surface normal, specularity, transparency, illumination, and surface {displacementÂ}¿to name a few. Although the list is potentially endless, the techniques of texture mapping are essentially the same in all cases. This article surveys the fundamentals of texture mapping, which can be spilt into two topics: the geometric mapping that warps a texture onto a surface, and the filtering necessary to avoid aliasing. An extensive bibliography is included.},
	pages = {56--67},
	journaltitle = {Computer Graphics and Applications, {IEEE}},
	shortjournal = {Computer Graphics and Applications, {IEEE}},
	author = {Heckbert, Paul},
	date = {1986-12-01},
	file = {Full Text PDF:/home/leix/Zotero/storage/NHGG7H54/Heckbert - 1986 - Survey Of Texture Mapping.pdf:application/pdf}
}

@online{noauthor_cuda_nodate,
	title = {{CUDA} Toolkit Documentation},
	url = {https://docs.nvidia.com/cuda/index.html},
	urldate = {2021-06-12},
	file = {CUDA Toolkit Documentation:/home/leix/Zotero/storage/AAPTWXZI/index.html:text/html}
}

@article{noauthor_cuda_nodate-1,
	title = {{CUDA} C++ Programming Guide},
	pages = {399},
	langid = {english},
	file = {CUDA C++ Programming Guide.pdf:/home/leix/Zotero/storage/C995RXCJ/CUDA C++ Programming Guide.pdf:application/pdf}
}

@inproceedings{fernando_percentage-closer_2005,
	location = {Los Angeles, California},
	title = {Percentage-closer soft shadows},
	url = {http://portal.acm.org/citation.cfm?doid=1187112.1187153},
	doi = {10.1145/1187112.1187153},
	eventtitle = {{ACM} {SIGGRAPH} 2005 Sketches},
	pages = {35},
	booktitle = {{ACM} {SIGGRAPH} 2005 Sketches on   - {SIGGRAPH} '05},
	publisher = {{ACM} Press},
	author = {Fernando, Randima},
	urldate = {2021-06-12},
	date = {2005},
	langid = {english},
	file = {Fernando - 2005 - Percentage-closer soft shadows.pdf:/home/leix/Zotero/storage/9FKBRIT6/Fernando - 2005 - Percentage-closer soft shadows.pdf:application/pdf}
}

@online{noauthor_event_nodate,
	title = {Event Management},
	url = {https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__EVENT.html},
	type = {{cppModule}},
	urldate = {2021-06-12},
	langid = {english}
}

@report{noauthor_sli_2011,
	title = {{SLI} Best Practices},
	url = {http://developer.download.nvidia.com/whitepapers/2011/SLI_Best_Practices_2011_Feb.pdf},
	urldate = {2021-06-12},
	date = {2011-02-15},
	file = {SLI_Best_Practices_2011_Feb.pdf:/home/leix/Zotero/storage/D9HQEWZ6/SLI_Best_Practices_2011_Feb.pdf:application/pdf}
}

@online{noauthor_amd_nodate,
	title = {{AMD} Crossfire Technology},
	url = {https://www.amd.com/en/technologies/crossfire},
	urldate = {2021-06-12},
	langid = {english}
}

@online{noauthor_sli_nodate,
	title = {{SLI} - {GeForce}},
	url = {https://www.nvidia.com/en-gb/geforce/technologies/sli/},
	urldate = {2021-06-12},
	file = {sli | GeForce:/home/leix/Zotero/storage/BDBKREIB/sli.html:text/html}
}

@article{memeti_benchmarking_2017,
	title = {Benchmarking {OpenCL}, {OpenACC}, {OpenMP}, and {CUDA}: programming productivity, performance, and energy consumption},
	shorttitle = {Benchmarking {OpenCL}, {OpenACC}, {OpenMP}, and {CUDA}},
	abstract = {Many modern parallel computing systems are heterogeneous at their node level. Such nodes may comprise general purpose {CPUs} and accelerators (such as, {GPU}, or Intel Xeon Phi) that provide high performance with suitable energy-consumption characteristics. However, exploiting the available performance of heterogeneous architectures may be challenging. There are various parallel programming frameworks (such as, {OpenMP}, {OpenCL}, {OpenACC}, {CUDA}) and selecting the one that is suitable for a target context is not straightforward. In this paper, we study empirically the characteristics of {OpenMP}, {OpenACC}, {OpenCL}, and {CUDA} with respect to programming productivity, performance, and energy. To evaluate the programming productivity we use our homegrown tool {CodeStat}, which enables us to determine the percentage of code lines that was required to parallelize the code using a specific framework. We use our tool x-{MeterPU} to evaluate the energy consumption and the performance. Experiments are conducted using the industry-standard {SPEC} benchmark suite and the Rodinia benchmark suite for accelerated computing on heterogeneous systems that combine Intel Xeon E5 Processors with a {GPU} accelerator or an Intel Xeon Phi co-processor.},
	author = {Memeti, Suejb and Li, Lu and Pllana, Sabri and Kolodziej, Joanna and Kessler, Christoph},
	date = {2017-04-18},
	eprinttype = {arxiv},
	eprint = {1704.05316},
	keywords = {Computer Science - Distributed, Parallel, and Cluster Computing, Computer Science - Programming Languages, Computer Science - Performance, Computer Science - Software Engineering},
	file = {arXiv Fulltext PDF:/home/leix/Zotero/storage/BLETGA5U/Memeti et al. - 2017 - Benchmarking OpenCL, OpenACC, OpenMP, and CUDA pr.pdf:application/pdf;arXiv.org Snapshot:/home/leix/Zotero/storage/FLBAVG47/1704.html:text/html}
}

@software{university_of_virginia_rodinia_nodate,
	title = {Rodinia: Accelerating Compute-Intensive Applications with Accelerators},
	url = {https://www.cs.virginia.edu/rodinia/doku.php},
	publisher = {University of Virginia},
	author = {University of Virginia},
	urldate = {2021-06-12},
	file = {start [Rodinia]:/home/leix/Zotero/storage/5B9623TU/doku.html:text/html}
}

@online{noauthor_3_2014,
	title = {3 Versatile {OpenACC} Interoperability Techniques},
	url = {https://developer.nvidia.com/blog/3-versatile-openacc-interoperability-techniques/},
	abstract = {{OpenACC} is a high-level programming model for accelerating applications with {GPUs} and other devices using compiler directives compiler directives to specify loops and regions of code in standard C…},
	titleaddon = {{NVIDIA} Developer Blog},
	urldate = {2021-06-12},
	date = {2014-09-02},
	langid = {american},
	file = {Snapshot:/home/leix/Zotero/storage/LC4V26S5/3-versatile-openacc-interoperability-techniques.html:text/html}
}

@article{noauthor_openacc_nodate,
	title = {{OpenACC} Programming and Best Practices Guide},
	url = {https://www.openacc.org/sites/default/files/inline-files/OpenACC_Programming_Guide_0_0.pdf},
	pages = {5},
	langid = {english},
	file = {OpenACC Programming and Best Practices Guide.pdf:/home/leix/Zotero/storage/QH4GNXKS/OpenACC Programming and Best Practices Guide.pdf:application/pdf}
}

@article{kreutz_cuda_2017,
	title = {{CUDA} Streams, Events and asynchronous memory copies},
	pages = {26},
	author = {Kreutz, Jochen},
	date = {2017},
	langid = {english},
	file = {Kreutz - 2017 - CUDA Streams, Events and asynchronous memory copie.pdf:/home/leix/Zotero/storage/PEQC54Q9/Kreutz - 2017 - CUDA Streams, Events and asynchronous memory copie.pdf:application/pdf}
}

@online{noauthor_chapter_nodate,
	title = {Chapter 11. Shadow Map Antialiasing},
	url = {https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-11-shadow-map-antialiasing},
	abstract = {Chapter 11. Shadow Map Antialiasing Michael Bunnell {NVIDIA} Fabio Pellacini Pixar Animation Studios 11.1 Introduction Shadow mapping is the method of choice for creating shadows in high-end rendering for motion pictures and television. However, it has been problematic to use shadow mapping in real-time applications, such as video games, because of aliasing problems in the form of magnified jaggies. This chapter shows how to significantly reduce shadow map aliasing in a shader. It describes how to implement a simplified version of percentage-closer filtering that makes the most out of the {GPU}'s shadow-mapping hardware to render soft-edged, antialiased shadows at real-time rates. Shadow mapping involves projecting a shadow map on geometry and comparing the shadow map values with the light-view depth at each pixel. If the projection causes the shadow map to be magnified, aliasing in the form of large, unsightly jaggies will appear at shadow borders. Aliasing can usually be reduced by using higher-resolution shadow maps and increasing the shadow map resolution, using techniques such as perspective shadow maps (Stamminger and Drettakis 2002). However, using perspective shadow-mapping techniques and increasing shadow map resolution does not work when the light is traveling nearly parallel to the shadowed surface, because the magnification approaches infinity. High-end rendering software solves the aliasing problem by using a technique called percentage-closer filtering. 11.2 Percentage-Closer Filtering Unlike normal textures, shadow map textures cannot be prefiltered to remove aliasing. Instead, multiple shadow map comparisons are made per pixel and averaged together. This technique is called percentage-closer filtering ({PCF}) because it calculates the percentage of the surface that is closer to the light and, therefore, not in shadow. The original {PCF} algorithm, described in Reeves et al. 1987, called for mapping the region to be shaded into shadow map space and sampling that region stochastically (that is, randomly). The algorithm was first implemented using the {REYES} rendering engine, so the region to be shaded meant a four-sided micropolygon. Figure 11-1 shows an example of that implementation. Figure 11-1 Percentage-Closer Filtering In our implementation, we have changed the {PCF} algorithm slightly to make it easy and efficient to apply. Instead of calculating the region to be shaded in shadow map space, we simply use a 4x4-texel sample region everywhere. This region is large enough to significantly reduce aliasing, but not so large as to require huge numbers of samples or stochastic sampling techniques to achieve good results. Note that the sampling region is not aligned to texel boundaries. An aligned region would not achieve the antialiasing effect that we want. Hardware shaders work on pixels, not on micropolygons, so matching the original implementation would involve transforming a four-sided polygon representing a screen pixel into shadow map space to calculate the sample region. Our implementation uses a fixed-size sample region instead. A fixed-size region lets us skip a complicated transformation and allows us to calculate a precise shadow percentage instead of an approximate one using stochastic sampling. See Figure 11-2. Figure 11-2 Sampling an Area of 4x4 Texels 11.3 A Brute-Force Implementation {NVIDIA} {GPUs} have built-in percentage-closer filtering for shadow map sampling. The hardware does four depth compares and uses the fractional part of the texture coordinate to bilinearly interpolate the shadow value. The shadow result is the percentage that a texel-size sample area is in shadow. See Figure 11-3. A single texel-size sample region is not big enough to effectively remove aliasing, but the region can be increased to a 4x4 texel size by averaging 16 shadow compare values. The offsets for x and y are -1.5, -0.5, 0.5, and 1.5 for samples one texel unit apart. Figure 11-3 Using the Hardware The following function can be used to do a projected texture map read with an offset given in texel units. The variable texmapscale is a float2 containing 1/width and 1/height of the shadow map. float3 offset\_lookup(sampler2D map, float4 loc, float2 offset) \{ return tex2Dproj(map, float4(loc.xy + offset * texmapscale * loc.w, loc.z, loc.w)); \} We can implement the 16-sample version in a fragment program as follows: float sum = 0; float x, y; for (y = -1.5; y 1.1) offset.y = 0; {shadowCoeff} = (offset\_lookup(shadowmap, {sCoord}, offset + float2(-1.5, 0.5)) + offset\_lookup(shadowmap, {sCoord}, offset + float2(0.5, 0.5)) + offset\_lookup(shadowmap, {sCoord}, offset + float2(-1.5, -1.5)) + offset\_lookup(shadowmap, {sCoord}, offset + float2(0.5, -1.5)) ) * 0.25; 11.5 Why It Works How can we antialias shadows with a fixed-size sample region even though texture projection can greatly magnify the shadow map? The answer is simple: When a texture is magnified, the texture map samples are close to each other for adjacent pixels. If the samples are close to each other and the sampled area is relatively large, then there can be only a very small difference between the shadow values, because the sample areas overlap a lot. Figure 11-5 shows how sample areas for adjacent pixels overlap when the shadow map is magnified. Figure 11-5 Overlapping Sampling Regions for Adjacent Pixels The more the shadow map is magnified, the smaller the difference between adjacent pixels, and the smoother the transition between shadowed and unshadowed regions. The hardware calculates that shadow percentage with eight bits of precision, so even in the case of extreme magnification and high-contrast shadows, there will always be a smooth shadow transition without banding. If the shadow regions are very close to each other, the shadow value will differ only by the least significant bit for eight-bits-per-component output. This is illustrated in Figures 11-6, 11-7, and 11-8, which show shadows for a ninja model with 1, 4, and 16 samples, respectively. Figure 11-9 shows a magnification of the ninja's thumb shadow in each of the three cases. Notice the vastly improved shadow quality in the 16-sample case. Figure 11-6 Ninja Shadow with One Sample per Pixel Figure 11-7 Ninja Shadow with Four Dithered Samples per Pixel Figure 11-8 Ninja Shadow with Sixteen Samples per Pixel Figure 11-9 The Shadows Magnified 11.6 Conclusion Shadow mapping is a popular method for rendering shadows, but it suffers from aliasing artifacts. We can greatly reduce shadow map aliasing by averaging multiple shadow map values. If we take advantage of the {GPU}'s shadow-mapping hardware and use clever sampling techniques, we can render soft-edged, antialiased shadows at high frame rates. 11.7 References Fernando, Randima, and Mark Kilgard. 2003. The Cg Tutorial. Addison-Wesley. This introduction to the Cg language has a good section on shadow mapping. Reeves, W. T., D. H. Salesin, and P. L. Cook. 1987. "Rendering Antialiased Shadows with Depth Maps." Computer Graphics 21(4) (Proceedings of {SIGGRAPH} 87). Stamminger, Marc, and George Drettakis. 2002. "Perspective Shadow Maps." In Proceedings of {SIGGRAPH} 2002, pp. 557–562. Copyright Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this book, and Addison-Wesley was aware of a trademark claim, the designations have been printed with initial capital letters or in all capitals. The authors and publisher have taken care in the preparation of this book, but make no expressed or implied warranty of any kind and assume no responsibility for errors or omissions. No liability is assumed for incidental or consequential damages in connection with or arising out of the use of the information or programs contained herein. The publisher offers discounts on this book when ordered in quantity for bulk purchases and special sales. For more information, please contact:       U.S. Corporate and Government Sales       (800) 382-3419       corpsales@pearsontechgroup.com For sales outside of the U.S., please contact:       International Sales       international@pearsoned.com Visit Addison-Wesley on the Web: www.awprofessional.com Library of Congress Control Number: 2004100582 {GeForce}™ and {NVIDIA} Quadro® are trademarks or registered trademarks of {NVIDIA} Corporation. {RenderMan}® is a registered trademark of Pixar Animation Studios. "Shadow Map Antialiasing" © 2003 {NVIDIA} Corporation and Pixar Animation Studios. "Cinematic Lighting" © 2003 Pixar Animation Studios. Dawn images © 2002 {NVIDIA} Corporation. Vulcan images © 2003 {NVIDIA} Corporation. Copyright © 2004 by {NVIDIA} Corporation. All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form, or by any means, electronic, mechanical, photocopying, recording, or otherwise, without the prior consent of the publisher. Printed in the United States of America. Published simultaneously in Canada. For information on obtaining permission for use of material from this work, please submit a written request to:       Pearson Education, Inc.       Rights and Contracts Department       One Lake Street       Upper Saddle River, {NJ} 07458 Text printed on recycled and acid-free paper. 5 6 7 8 9 10 {QWT} 09 08 07 5th Printing September 2007},
	titleaddon = {{NVIDIA} Developer},
	urldate = {2021-06-12},
	langid = {english},
	file = {Snapshot:/home/leix/Zotero/storage/R74MU98H/chapter-11-shadow-map-antialiasing.html:text/html}
}

@collection{haines_ray_2019,
	title = {Ray Tracing Gems},
	publisher = {Apress},
	editor = {Haines, Eric and Akenine-Möller, Tomas},
	date = {2019}
}

@online{haines_ray_2020,
	title = {Ray Tracing Essentials},
	url = {https://developer.nvidia.com/blog/ray-tracing-essentials-part-1-basics-of-ray-tracing/},
	shorttitle = {Ray Tracing Essentials},
	abstract = {Ray Tracing Essentials is a seven-part video series hosted by the editor of Ray Tracing Gems, {NVIDIA}’s Eric Haines.},
	titleaddon = {{NVIDIA} Developer Blog},
	type = {Blog},
	author = {Haines, Eric},
	urldate = {2021-06-13},
	date = {2020-01-18},
	langid = {american},
	file = {Snapshot:/home/leix/Zotero/storage/UF3INZYK/ray-tracing-essentials-part-1-basics-of-ray-tracing.html:text/html}
}

@article{richter_enhancing_2021,
	title = {Enhancing Photorealism Enhancement},
	url = {https://intel-isl.github.io/PhotorealismEnhancement/},
	journaltitle = {{arXiv}:2105.04619},
	author = {Richter, Stephan R. and {AlHaija}, Hassan Abu and Koltun, Vladlen},
	date = {2021}
}