%! TEX root = **/010-main.tex
% vim: spell spelllang=es:

% Antes de empezar el examen, leed atentamente los siguientes comentarios:
%
% - Esto es un examen y los exámenes se hacen de forma individual.
%
% - La fecha límite para entregar el examen (y el proyecto) es el lunes 21 de
%   junio de 2021 a las 8:00.
%
% - He montado una “práctica” en el racó para hacer la entrega del examen.
%
% - El examen que entreguéis ha de ser un PDF.
%
% - Hemos calculado que el tiempo necesario para realizar el examen son unas
%   20-30 horas de trabajo. No lo dejéis para el final.
%
% - Teniendo en cuenta que tenéis mucho tiempo para hacer el examen, una buena
% redacción y ortografía se tendrá en cuenta en la evaluación.
%
% - No os limitéis a la información que hay en las transparencias del curso, hay
%   que buscar en otras fuentes.
%
% - Además del examen tenéis que entregar un anexo, en el que, para cada
%   pregunta, indiquéis las referencias, páginas web, etc. que habéis consultado
%   durante el examen.
%
% - El examen consta de:
%   - 6 preguntas estándar (2 hojas por pregunta, aprox.  1000 palabras por pregunta).
%   - 1 pregunta doble, es cómo un pequeño trabajo (4 hojas, aprox. 2000 palabras)

\begin{pregunta}{Describe el pipeline gráfico tradicional}\sep{}

El pipeline gráfico tradicional tiene como objetivo la generación de gráficos
explotando al máximo el paralelismo que ofrecen las GPUs. Para ello el pipeline
organiza las distintas tareas a realizar de forma coherente aprovechando al
máximo las capacidades de las GPUs y ocultando la latencia de memoria. Este
pipeline es relativamente simple en comparación al actual y muy limitado en
capacidad de programar su funcionamiento: solo hay dos \emph{shaders} que pueden
hacer operaciones muy limitadas.

El pipeline se puede dividir en 4 etapas principales. Aunque hay un orden en
estas etapas, algunas operaciones se pueden realizar simultáneamente y así
aprovechar el paralelismo que ofrece la GPU.

\begin{enumerate}
    \item Vértices
    \item Primitivas
    \item Fragmentos
    \item Pixels
\end{enumerate}

\paragraph{Vértices} En el procesado de vértices se proyectan los vértices sobre
el plano de visión según la configuración de proyección y la camera. También se
pueden aplicar cálculos de iluminación y color o otras transformaciones
sobre los vértices del modelo o la cámara. En el pipeline tradicional estas
operaciones se realizan en el \emph{vertex shader} donde se programa como se
hacen los cálculos. Estas operaciones se realizan en paralelo para diversos
grupos de pixels.

\paragraph{Primitivas} Partiendo de los vértices procesados en la etapa anterior
se generan primitivas agrupándolos en triángulos. Se eliminan primitivas
innecesarias (que no se verán en la imagen final). Para ello se aplica un
proceso de \emph{CLIPPING} y \emph{CULLING}. El \emph{CLIPPING} consiste en
eliminar las primitivas que queden fuera del campo de visión (o parte de ellas,
dividiéndolas en triángulos). \emph{CULLING} usa el \emph{z-buffer} para
determinar que primitivas quedan ocultas detrás de otras y eliminar-las de modo
similar al \emph{CLIPPING}. En algunos casos la etapa de \emph{CULLING} no se
puede aplicar debido a la transparencia de los objetos. Eliminar primitivas
permite evitar computaciones innecesarias en las siguientes etapas.

Antes de pasar a la siguiente fase, se calculan las ecuaciones que forman los
triángulos (\emph{triangle setup}) que serán usadas en las otras etapas. Este
calculo es muy costoso y poco eficiente si tenemos triángulos muy pequeños.

\paragraph{Fragmentos} En esta etapa se generan y procesan los fragmentos
(grupos de pixels de la imagen que pertenecen a un mismo triangulo). La
generación de los fragmentos se denomina \emph{rasterización} y consiste en
calcular para cada triangulo que pixels de la imagen final forman parte de el.
Una vez \emph{rasterizados} los fragmentos se procesan en el \emph{fragment
shader} que permite aplicar transformaciones a los fragmentos (como antialiasing) y
calcular su color (u otros atributos). Al igual que el \emph{vertex shader}, se
puede programar. En el \emph{fragment shader} se puede aplicar texturas
almacenadas en la memoria de texturas de la tarjeta.

\paragraph{Pixels} En la etapa final se aplican operaciones sobre los fragmentos
antes de trasladar-los al \emph{frame-buffer}. Hay dos tipos de operaciones
posibles, las de aceptación/rechazo en las que se decide si el pixel se copiara
al \emph{frame buffer} o no y las de \emph{combinación} que combinan los colores
de varios pixels. Las operaciones de aceptación/rechazo se realizan mediante
\emph{tests}. Tenemos los siguientes:

\begin{enumerate}
    \item \textbf{Scissor test} Recorta el área de renderizado. Solo hace falta
        almacenar los parámetros que definen el área rectangular de renderizado.
    \item \textbf{Alpha test} Descarta pixels con valor \emph{alpha}
        (transparencia) de 0 o muy cercanos a 0.
    \item \textbf{Stencil test} Usado para dibujar sombras: se proyectan sobre
        el \emph{stencil buffer} y al renderizar se hacen dos pasadas dibujando
        los elementos fuera del \emph{stencil} con iluminación y los marcados en
        el sin iluminación. También se puede usar para recortar el área de
        renderizado con formas no rectangulares.
    \item \textbf{Z test} Descarta fragmentos que quedan ocluidos por otros.
        Es una operación muy costosa y hay varias optimizaciones que se han ido
        aplicando a lo largo de los años.
    \item \textbf{Alpha Blending} Determina como combinar el color del
        \emph{frame buffer} con el del nuevo pixel según su transparencia (\emph{alpha})
        mediante un proceso de interpolación.
\end{enumerate}

Actualmente las etapas del pipeline gráfico tradicional se siguen aplicando en
las GPUs pero han habido muchos cambios en su funcionamiento y arquitectura.
Quizás el más notable son los \emph{shaders}. En las tarjetas gráficas actuales
los \emph{shaders} estan unificados, que permiten que los \emph{vertex} y
\emph{fragment shaders} usen los mismos elementos de cálculo. También
hay nuevos \emph{shaders} (\emph{Geometry}, \emph{Hull}, \emph{Domain})
que las APIs gráficas pueden implementar ya que al estar unficados los \emph{shaders}
se puede mezclar mejor los elementos programables y los fijos y añadir procesos
programables en el pipeline sin necesidad de cambiar la arquitectura de la tarjeta.
Además los \emph{shaders} tienen más capacidades permitiendo acceso a memoria
convencional instrucciones de control de flujo y más registros.

\paragraph{Referencias:}
\cite{lawrence_3d_2012}
\cite{rmit_-_cs_lecture_2017}
\cite{moller_real-time_2018}
\cite{giesen_trip_2011}

\end{pregunta}

\begin{pregunta}{Dada la siguiente rutina escrita en C:}
    \begin{minted}{c}
    void Examen21(float mA[N][M], float mB[N][M], float vC[N], float vD[M]) {
      int i, j;
      for (i=0; i<N; i++)
        for (j=0; j<M; j++)
             mA[i][j] = mA[i][j]*vC[i] - mB[i][j]*vD[j] + mA[i][0]*mB[7][j];
    }
    \end{minted}

    Escribid 3 versiones del kernel CUDA que resuelva el mismo problema:

\begin{enumerate}[label=(\alph*)]
    \item En la primera versión cada thread se va a ocupar de 1 columna de la matriz resultado.
    \item En la segunda versión cada thread se va a ocupar de 1 fila de la matriz resultado.
    \item En la última versión cada thread se va a ocupar de 1 elemento de la matriz resultado.
\end{enumerate}

Escribid los kernels CUDA para cada versión, así como la invocación
correspondiente. Tened en cuenta que como máximo podéis utilizar 1024 threads
por bloque y que las variables N y M pueden tener cualquier valor (p.e. N =
1237, M = 2311, suponed que N, M > 1024).

\vspace{1em} \sep{}

Si analizamos las dependencias del código, vemos que \texttt{mA[i][j]} depende
del valor \texttt{mA[i][0]}, por lo que se tiene que calcular siempre la columna
0 antes que el resto. En el caso de 1 thread por fila no hay problema, pero los
otros deben sincronizarse adecuadamente.

Otro apunte importante es que trabajar con matrices en CUDA es complejo y puede
generar problemas (alocución no contigua en memoria de hileras), por lo que en
mi versión se usaran matrices aplanadas.

El código completo se encuentra en el~\cref{asec:codigo}.

\pagebreak
\subsection*{(a) Columna}

Para el \emph{kernel} de columna tenemos que asegurar-nos de que la primera columna
se ha calculado antes de proceder al resto. Para ello usamos un \emph{lock} que
se tiene que inicializar a 0 antes de la llamada al \emph{kernel} y al que solo el
primer thread del primer bloque escribe. Usamos un \texttt{while} para esperar a que
el valor del \emph{lock} este en 1 sincronizando los threads.

Otra alternativa sería ejecutar la primera columna en serie antes del \emph{kernel} y que el
thread de la primera columna no hiciera nada.

\begin{listing}[H]
    \caption{Kernel columna y su invocación}
    \inputminted[firstline=17,lastline=33]{cuda}{code/main.cu}
    \vspace{-2em}
    \inputminted[firstline=120,lastline=127,autogobble]{cuda}{code/main.cu}
    \label{lst:kernel-columna}
\end{listing}

\pagebreak
\subsection*{(b) Fila}

Para el \emph{kernel} de fila si empezamos cada fila por la columna 0 no hay ningún
problema de dependencias entre threads.

\begin{listing}[H]
    \caption{Kernel fila y su invocación}
    \inputminted[firstline=35,lastline=41]{cuda}{code/main.cu}
    \vspace{-2em}
    \inputminted[firstline=114,lastline=117,autogobble]{cuda}{code/main.cu}
    \label{lst:kernel-fila}
\end{listing}

\pagebreak
\subsection*{(c) Elemento}

Al igual que en el caso de las columnas, para calcular un elemento es necesario que
el valor de la primera columna de la fila en el que se encuentra el elemento se haya
calculado antes. Pero a diferencia del caso de las columnas, podemos calcular todos los
elementos de la primera columna en paralelo. Para ello usaremos un \emph{lock} de
\emph{N} posiciones en el que el primer bloque del primer thread escribirá en la posición
de la fila en la que se ha calculado. Al igual que en el caso de las columnas usamos un
\texttt{while} con el \emph{lock} para esperar a que se completen estos elementos.

\begin{listing}[H]
    \caption{Kernel elemento y su invocación}
    \inputminted[firstline=43,lastline=57]{cuda}{code/main.cu}
    \vspace{-2em}
    \inputminted[firstline=130,lastline=137,autogobble]{cuda}{code/main.cu}
    \label{lst:kernel-elemento}
\end{listing}

\end{pregunta}

\begin{pregunta}{Disponemos de una tarjeta gráfica con 2 GPUs. En esta tarjeta queremos
    correr un juego interactivo 3D (que utiliza OpenGL u otra API similar). Si
    estuvierais diseñando el driver de la API gráfica, ¿cómo distribuirías el
    trabajo entre las 2 GPUs para maximizar el rendimiento?  ¿Qué información
    hay que enviar a cada tarjeta? ¿Han de sincronizarse/comunicarse las 2 GPUs?
    ¿Cómo pueden hacerlo? Os ayudará tener en mente cómo funciona el pipeline
gráfico} \sep{}

\end{pregunta}
\begin{pregunta}{Una de las herramientas que utilizamos en CUDA son los eventos (event en
CUDA). ¿Para qué sirven? ¿Cómo se utilizan? Pon ejemplos de uso.} \sep{}

\end{pregunta}
\begin{pregunta}{Si queremos utilizar GPUs para cálculo de propósito general (GPGPU)
    puedes escoger entre CUDA, OpenCL y OpenACC. Describe las ventajas e
    inconvenientes de cada alternativa.  Además, se pueden combinar. ¿Qué
posibilidades ofrece combinar OpenACC con CUDA o OpenCL?} \sep{}

\paragraph{CUDA} es la solución de \emph{GPGPU} ofrecida por \emph{Nvidia}. Es la más
popular actualmente debido a la facilidad de programar usando \emph{CUDA}. Debido a esto
hay muchas aplicaciones de calculo científico que usan \emph{CUDA} exclusivamente y es más fácil
encontrar información y recursos sobre su funcionalidad. El problema principal es que solo
las tarjetas gráficas de \emph{Nvidia} funcionan con \emph{CUDA} por lo que no se puede usar
con otras tarjetas.

\paragraph{OpenCL} ss

\paragraph{OpenACC} es la otra

\end{pregunta}
\begin{pregunta}{Hablando de texturas, ¿qué filtros existen?, ¿puedes describirlos? ¿qué
implicaciones tienen en el diseño de la GPU?} \sep{}
\end{pregunta}
